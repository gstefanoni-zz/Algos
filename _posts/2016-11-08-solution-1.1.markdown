---
layout: post
title:  "Solutions to Exercises in Section 1.1"
date:   2016-11-08 15:09:39
categories: solutions 
---

In this first post, I present my solutions to the exercises in Section 1.1.
These exercises are quite introductory and do not require much effort, so let's
start straight away.

### Exercise 1.1-1:
    
> Give a real-world example that requires sorting or a real-world example
> that requires computing a convex hull

We give an example that requires sorting. Company A wants to generate an
online email directory of all its employee. Since email directories are sorted
by name, the IT manager of Company A generates the directory by first sorting
the list of all employees by name, and then by iterating through the sorted
sequence and output a pair (employee_name, email_address) for each employee.
    
### Exercise 1.1-2:
    
> Other than speed, what other measures of efficiency might one
> use in a real-world setting?
    
The memory footprint of an algorithm is also an important measure of
efficiency. An algorithm that uses an exponential amount of memory in the input
size is only viable for input of small sizes.

### Exercise 1.1.-3:

> Select a data structure that you have seen previously, and discuss its
> strengths and limitations.
    
We look at the strengths and limitation of the [array data
structure](https://en.wikipedia.org/wiki/Array_data_structure).

An important strength of arrays is that they allow for constant time indexing:
that is, we can access the i-th element in the sequence very efficiently.

A limitation of arrays is that changing its structure, that is removing or
adding one element to the sequence, requires allocating a new array and copying
the contents of the old array to the new one.

### Exercise 1.1.-4:
    
> How are the shortest-path and travelling-salesman problems given above
> similar? How are they different?
    
I will first formalise the two problems in a mathematical language.

A (undirected) graph is a triple $$G =(V, E, w)$$ where $$V$$ is a set of
vertices, $$E$$ is a set of edges of the form $$\{v, v'\}$$ with $$v,v'\in V$$,
and $$w$$ is a weight function that associates a positive natural number to
each $$(v, v') \in E$$. A path $$p$$ from a vertex $$s$$ to a vertex $$t$$ in
$$G$$ is a sequence $$p = v_0, \ldots, v_n$$ of vertices from $$V$$ such that
$$n > 0$$, $$v_0 = s$$ and $$v_n = t$$, and $$\{v_{i-1}, v_i\} \in E$$ for each
$$i \in \{1,\ldots, |V|\}$$. The cost of such a path $$p$$ is defined as
follows.

$$
\mathsf{cost}(p) = \sum_{i=1}^n w(\{v_{i-1}, v_i\})
$$

Then, the [shortest path
problem](https://en.wikipedia.org/wiki/Shortest_path_problem) can be formally
defined as follows.

* * *

*shortest path problem*

**Input**: A graph $$G = (V, E, w)$$ and two vertices $$s,t\in V$$.

**Output**: A path $$p$$ from $$s$$ to $$t$$ in $$G$$ such that no path $$p'$$
from $$s$$ to $$t$$ exists in $$G$$ such that $$\mathsf{cost}(p') <
\mathsf{cost}(p)$$. The result is undefined if no such path exists.

***

We next formalise the travelling-salesman problem.

* * *

*travelling-salesman problem*

**Input**: A graph $$G = (V, E, w)$$ and a starting vertex $$v_0\in V$$.

**Output**: A permutation $$p = v_0, \ldots, v_n$$ of the
vertices in $$V$$ such that $$p, v_0$$ is a path in $$G$$ and no other
permutation $$p'$$ of $$V$$ exists such that $$p', v_0$$ is a path in $$G$$
and $$\mathsf{cost}(p') < \mathsf{cost}(p)$$.

* * *

The two problems are similar in that they both require to find a minimum cost
path in a graph. However, a solution to the shortest path problem is a minimum
cost path connecting two vertices in the graph. On the other hand, a solution
to the travelling-salesman problem is a minimum cost path that starts from a
given vertex $$v_0$$, touches every other vertex in $$G$$ exactly ones, and
ends at $$v_0$$. In particular, a solution to the travelling-salesman problem
**cannot** be found by first computing the shortest path between each pair of
vertices in $$G$$, and then combining these partial solutions: indeed, the
resulting path would not necessarily touch each vertex other than $$v_0$$
precisely once.

### Exercise 1.1-5:

> Come up with a real-world problem in which only the best solution will do.
> Then come up with one in which a solution that is "approximately" the best
> is good enough.
    
The travelling-salesman problem is an instance of a problem where we can output
a close to optimal solution. However, answering SQL queries over relational
databases is an example of a problem in which typically only the correct
solution would do: one cannot return to the user a result that contains
spurious rows.

